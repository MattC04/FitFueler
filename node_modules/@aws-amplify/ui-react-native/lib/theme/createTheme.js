"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTheme = void 0;
const tslib_1 = require("tslib");
const deepExtend_1 = tslib_1.__importDefault(require("style-dictionary/lib/utils/deepExtend"));
const resolveObject_1 = tslib_1.__importDefault(require("style-dictionary/lib/utils/resolveObject"));
const usesReference_1 = tslib_1.__importDefault(require("style-dictionary/lib/utils/references/usesReference"));
const ui_1 = require("@aws-amplify/ui");
const defaultTheme_1 = require("./defaultTheme");
// This will resolve all references in component themes by either
// calling the component theme function with the already resolved base tokens
// OR
// resolving the component theme object
const setupComponents = ({ components, tokens, }) => {
    const output = components
        ? Object.entries(components).reduce((acc, [key, value]) => ({
            ...acc,
            [key]: (0, ui_1.isFunction)(value) ? value(tokens) : value,
        }), {})
        : {};
    return (0, resolveObject_1.default)({
        ...tokens,
        components: output,
    }).components;
};
const shouldParseFloatValue = (pathKey) => [
    'space',
    'borderWidths',
    'opacities',
    'fontSizes',
    'lineHeights',
    'radii',
].includes(pathKey);
const setupToken = ({ token, path = [], spaceModifier, }) => {
    const { value } = token;
    if (typeof value === 'string') {
        // Remove .value from references if there is a reference
        // this needs to come first so we don't get NaNs for references
        if ((0, usesReference_1.default)(value)) {
            return value.replace('.value', '');
        }
        if (shouldParseFloatValue(path[0])) {
            if (value.includes('rem')) {
                if (path[0] === 'space') {
                    return Math.floor(parseFloat(value) * 16 * spaceModifier);
                }
                return Math.floor(parseFloat(value) * 16);
            }
            if (value.includes('px')) {
                return parseInt(value, 10);
            }
            return parseFloat(value);
        }
        return value;
    }
    // Font Weights in RN are strings
    if (path[0] === 'fontWeights') {
        return `${value}`;
    }
    return value;
};
/**
 * This will be used like `const myTheme = createTheme({})`
 * `myTheme` can then be passed to a Provider
 * const myTheme = createTheme({})
 * const myOtherTheme = createTheme({}, myTheme);
 */
const createTheme = (theme, colorMode) => {
    // merge custom `theme` param and `StrictTheme` to get the merged theme.
    // `deepExtend` is a Style Dictionary method that performs a deep merge on n objects.
    const mergedTheme = (0, deepExtend_1.default)([
        {},
        defaultTheme_1.defaultTheme,
        theme,
        // cast to `StrictTheme` as `deepExtend` returns a generic object
    ]);
    let { tokens: mergedTokens } = mergedTheme;
    const { spaceModifier = 1 } = mergedTheme;
    // We need to merge in any applicable overrides because we need to
    // resolve the values of all tokens at runtime based on which
    // overrides are present and should be applied
    if (theme?.overrides?.length) {
        theme.overrides.forEach((override) => {
            if (override?.colorMode === colorMode) {
                mergedTokens = (0, deepExtend_1.default)([
                    {},
                    mergedTokens,
                    override.tokens,
                ]);
            }
            // more overrides in the future could happen here
        });
    }
    // Setup the tokens:
    // - each token will have a raw value
    // - references to tokens (strings wrapped in curly braces) are replaced by raw values
    const tokens = (0, resolveObject_1.default)((0, ui_1.setupTokens)({
        tokens: mergedTokens,
        setupToken: ({ token, path }) => {
            return setupToken({ token, path, spaceModifier });
        },
    }));
    let components;
    // Resolve component token references too
    if (mergedTheme.components) {
        components = setupComponents({
            components: mergedTheme.components,
            tokens,
        });
    }
    return { ...mergedTheme, tokens, components };
};
exports.createTheme = createTheme;
