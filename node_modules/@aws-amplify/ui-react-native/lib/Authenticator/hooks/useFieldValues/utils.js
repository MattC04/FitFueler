"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runFieldValidation = exports.getRouteTypedFields = exports.getTypedFields = exports.getTypedField = exports.getSanitizedTextFields = exports.getSanitizedRadioFields = exports.isRadioFieldOptions = void 0;
const utils_1 = require("aws-amplify/utils");
const ui_1 = require("@aws-amplify/ui");
const ui_react_core_1 = require("@aws-amplify/ui-react-core");
const constants_1 = require("./constants");
const logger = new utils_1.ConsoleLogger('Authenticator');
const { getInvalidEmailText, getRequiredFieldText } = ui_1.authenticatorTextUtil;
const isRadioFieldOptions = (field) => field?.type === 'radio';
exports.isRadioFieldOptions = isRadioFieldOptions;
const getSanitizedRadioFields = (fields, componentName) => {
    const values = {};
    return fields.filter((field) => {
        if (!(0, exports.isRadioFieldOptions)(field)) {
            logger.warn(`${componentName} component does not support text fields. field with type ${field.type} has been ignored.`);
            return false;
        }
        const { name, value } = field;
        if (!value) {
            logger.warn('Each radio field must have a value. field has been ignored.');
            return false;
        }
        if (values[value]) {
            logger.warn(`Each radio field value must be unique. field with duplicate value of ${value} has been ignored.`);
            return false;
        }
        if (!(0, ui_1.isUnverifiedContactMethodType)(name)) {
            logger.warn(`field with name '${name}' has been ignored. Supported values are: ${Object.values(ui_1.UnverifiedContactMethodType)}.`);
            return false;
        }
        // add `value` key to `values`
        values[value] = true;
        return true;
    });
};
exports.getSanitizedRadioFields = getSanitizedRadioFields;
const getSanitizedTextFields = (fields, componentName) => {
    const names = {};
    return fields.filter((field) => {
        if ((0, exports.isRadioFieldOptions)(field)) {
            logger.warn(`${componentName} component does not support radio fields. field has been ignored.`);
            return false;
        }
        const { name } = field;
        if (!name) {
            logger.warn('Each field must have a name. field has been ignored.');
            return false;
        }
        if (names[name]) {
            logger.warn(`Each field name must be unique. field with duplicate name of ${name} has been ignored.`);
            return false;
        }
        names[name] = true;
        return true;
    });
};
exports.getSanitizedTextFields = getSanitizedTextFields;
// typed fields utils
const isKeyAllowed = (key) => constants_1.KEY_ALLOW_LIST.some((allowedKey) => allowedKey === key);
const isValidMachineFieldType = (type) => type === 'password' || type === 'tel' || type == 'email';
const getFieldType = (type) => {
    if (isValidMachineFieldType(type)) {
        return type === 'tel' ? 'phone' : type;
    }
    return 'default';
};
/**
 * Translate machine fields to typed fields
 *
 * @param {AuthenticatorLegacyField} field machine field option object
 * @returns {TypedField} UI field props object
 */
const getTypedField = ({ type: machineFieldType, name, ...field }) => {
    const type = getFieldType(machineFieldType);
    const testID = `authenticator__text-field__input-${name}`;
    return Object.entries(field).reduce((acc, [key, value]) => {
        // early return if key is not allowed
        if (!isKeyAllowed(key)) {
            return acc;
        }
        // map to `required` prop
        if (key === 'isRequired' || key === 'required') {
            // `TypedField` props expects `required` key
            return { ...acc, required: value, testID };
        }
        return { ...acc, [key]: value, testID };
    }, 
    // initialize `acc` with field `name` and `type`
    { name, type });
};
exports.getTypedField = getTypedField;
/**
 * @param {AuthenticatorLegacyField[]} fields machine field options array
 * @returns {TypedField[]} UI field props array
 */
const getTypedFields = (fields) => fields?.map(exports.getTypedField);
exports.getTypedFields = getTypedFields;
function getRouteTypedFields({ fields, route, }) {
    const isComponentRoute = (0, ui_react_core_1.isAuthenticatorComponentRouteKey)(route);
    if (!isComponentRoute) {
        return [];
    }
    // `VerifyUser` does not require additional updates to the shape of `fields`
    const isVerifyUserRoute = route === 'verifyUser';
    const radioFields = fields;
    return isVerifyUserRoute ? radioFields : (0, exports.getTypedFields)(fields);
}
exports.getRouteTypedFields = getRouteTypedFields;
/**
 *
 * @param {TextFieldOptionsType} field text field type
 * @param {string | undefined} value text field value
 * @param {string[]} stateValidations validation errors array from state machine
 * @returns {string[]} field errors array
 */
const runFieldValidation = (field, value, stateValidations) => {
    const fieldErrors = [];
    if (field.required && !value) {
        fieldErrors.push(getRequiredFieldText());
    }
    if (field.type === 'email') {
        if (!(0, ui_1.isValidEmail)(value?.trim())) {
            fieldErrors.push(getInvalidEmailText());
        }
    }
    // add state machine validation errors, if any
    const stateFieldValidation = stateValidations?.[field.name];
    if (stateFieldValidation) {
        if ((0, ui_1.isString)(stateFieldValidation)) {
            fieldErrors.push(stateFieldValidation);
        }
        else {
            return fieldErrors.concat(stateFieldValidation);
        }
    }
    return fieldErrors;
};
exports.runFieldValidation = runFieldValidation;
